{"version":3,"sources":["../../../src/services/term.ts"],"names":["TermActionEnum","getTsvContent","logError","parseTerm","UniqTermKeyTermError","path","validateTerm","deleteTerm","insertTerm","updateTerm","BaseTermError","runTermService","connector","config","filePath","skipHeader","records","termsCollection","Map","position","length","data","key","parentTermName","termName","has","get","push","set","terms","error","filename","basename","logPath","delete","action","toUpperCase","INSERT","DEFAULT","customFieldsId","UPDATE","DELETE","e","termParentName"],"mappings":"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","sourcesContent":["import {Alation} from 'alation_connector';\nimport {IConfig, TermActionEnum, TermsCollection} from '../types';\nimport {getTsvContent, logError} from '../helpers/fileReader';\nimport {parseTerm} from '../helpers/parser';\nimport {UniqTermKeyTermError} from '../errors/terms';\nimport path from 'path';\nimport {validateTerm} from '../helpers/validator';\nimport {deleteTerm, insertTerm, updateTerm} from '../helpers/actions';\nimport {BaseTermError} from '../errors';\n\nexport async function runTermService(connector: Alation, config:IConfig, filePath: string, skipHeader: boolean): Promise<void> {\n  const records = getTsvContent(filePath, skipHeader);\n  const termsCollection: TermsCollection = new Map();\n  for (let position = 0; position < records.length; position++) {\n    if (!records[position].length) {\n      continue;\n    }\n    const data = parseTerm(records[position]);\n    const key = `${data.parentTermName}.${data.termName}`;\n\n    if (termsCollection.has(key)) {\n      // @ts-ignore\n      termsCollection.get(key).push({data, position});\n    } else {\n      termsCollection.set(key, [{data, position}]);\n    }\n  }\n\n  for (const [key, terms] of termsCollection) {\n    if (terms.length > 1) {\n      for (const {data, position} of terms) {\n        const error = new UniqTermKeyTermError(data.termName, data.parentTermName);\n        error.position = position;\n        error.filename = path.basename(filePath);\n        logError(config.logPath, error);\n      }\n      termsCollection.delete(key);\n      continue;\n    }\n    const {data, position} = terms[0];\n    try {\n      validateTerm(data);\n      switch (data.action.toUpperCase()) {\n        case TermActionEnum.INSERT:\n        case TermActionEnum.DEFAULT:\n          await insertTerm(connector, config.customFieldsId, data);\n          break;\n        case TermActionEnum.UPDATE:\n          await updateTerm(connector, config.customFieldsId, data);\n          break;\n        case TermActionEnum.DELETE:\n          await deleteTerm(connector, data);\n      }\n    } catch (e) {\n      if (e instanceof BaseTermError) {\n        e.termName = data.termName;\n        e.termParentName = data.parentTermName;\n        e.position = position + 1;\n        e.filename = path.basename(filePath);\n        logError(config.logPath, e);\n        continue;\n      }\n      throw e;\n    }\n  }\n}\n"],"file":"term.js"}