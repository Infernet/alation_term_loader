{"version":3,"sources":["../../../src/services/term.ts"],"names":["runTermService","connector","config","filePath","skipHeader","records","termsCollection","Map","position","length","data","key","parentTermName","termName","has","get","push","set","terms","error","UniqTermKeyTermError","filename","path","basename","logPath","delete","action","toUpperCase","TermActionEnum","INSERT","DEFAULT","customFieldsId","UPDATE","DELETE","e","BaseTermError","termParentName"],"mappings":"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","sourcesContent":["import {Alation} from 'alation_connector';\nimport {IConfig, TermActionEnum, TermsCollection} from '../types';\nimport {getTsvContent, logError} from '../helpers/fileReader';\nimport {parseTerm} from '../helpers/parser';\nimport {UniqTermKeyTermError} from '../errors/terms';\nimport path from 'path';\nimport {validateTerm} from '../helpers/validator';\nimport {deleteTerm, insertTerm, updateTerm} from '../helpers/actions';\nimport {BaseTermError} from '../errors';\n\nexport async function runTermService(connector: Alation, config:IConfig, filePath: string, skipHeader: boolean): Promise<void> {\n  const records = getTsvContent(filePath, skipHeader);\n  const termsCollection: TermsCollection = new Map();\n  for (let position = 0; position < records.length; position++) {\n    if (!records[position].length) {\n      continue;\n    }\n    const data = parseTerm(records[position]);\n    const key = `${data.parentTermName}.${data.termName}`;\n\n    if (termsCollection.has(key)) {\n      // @ts-ignore\n      termsCollection.get(key).push({data, position});\n    } else {\n      termsCollection.set(key, [{data, position}]);\n    }\n  }\n\n  for (const [key, terms] of termsCollection) {\n    if (terms.length > 1) {\n      for (const {data, position} of terms) {\n        const error = new UniqTermKeyTermError(data.termName, data.parentTermName);\n        error.position = position;\n        error.filename = path.basename(filePath);\n        logError(config.logPath, error);\n      }\n      termsCollection.delete(key);\n      continue;\n    }\n    const {data, position} = terms[0];\n    try {\n      validateTerm(data);\n      switch (data.action.toUpperCase()) {\n        case TermActionEnum.INSERT:\n        case TermActionEnum.DEFAULT:\n          await insertTerm(connector, config.customFieldsId, data);\n          break;\n        case TermActionEnum.UPDATE:\n          await updateTerm(connector, config.customFieldsId, data);\n          break;\n        case TermActionEnum.DELETE:\n          await deleteTerm(connector, data);\n      }\n    } catch (e) {\n      if (e instanceof BaseTermError) {\n        e.termName = data.termName;\n        e.termParentName = data.parentTermName;\n        e.position = position + 1;\n        e.filename = path.basename(filePath);\n        logError(config.logPath, e);\n        continue;\n      }\n      throw e;\n    }\n  }\n}\n"],"file":"term.js"}